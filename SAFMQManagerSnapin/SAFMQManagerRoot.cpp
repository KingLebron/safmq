/*
 Copyright 2005 Matthew J. Battey

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed
	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	CONDITIONS OF ANY KIND, either express or implied. See the License for the
	specific language governing permissions and limitations under the License.




This software implements a platform independent Store and Forward Message Queue.
*/
#include "stdafx.h"
#include "SAFMQManagerSnapin.h"
#include "SAFMQManagerRoot.h"
#include "SafmqServerNode.h"
#include "ServerList.h"
#include "LocalSettings.h"
#include "NewServerDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFMQManagerRootComponentData
static const GUID CSAFMQManagerRootNode_NODETYPE = 
		{ 0x21f436d0, 0x53d5, 0x4c85, { 0x8b, 0xea, 0xe2, 0x62, 0x74, 0x16, 0x28, 0xeb } };

const GUID*		CSAFMQManagerRootNode::m_NODETYPE = &CSAFMQManagerRootNode_NODETYPE;
const OLECHAR*	CSAFMQManagerRootNode::m_SZNODETYPE = OLESTR("21F436D0-53D5-4C85-8BEA-E262741628EB");
const OLECHAR*	CSAFMQManagerRootNode::m_SZDISPLAY_NAME = OLESTR("SAFMQ Manager");	// Appears in the Context Pane as the node Name, but loaded only once at first add
const CLSID*	CSAFMQManagerRootNode::m_SNAPIN_CLASSID = &CLSID_SAFMQManagerRoot;

CSAFMQManagerRootNode::CSAFMQManagerRootNode(CSAFMQManagerRoot* root) : CNode<CSAFMQManagerRootNode, CSAFMQManagerRoot, CSAFMQManagerRootComponent>(root)
{
	// Image indexes may need to be modified depending on the images specific to 
	// the snapin.
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nImage = -1; 		// May need modification
	m_scopeDataItem.nOpenImage = -1; 	// May need modification
	m_scopeDataItem.lParam = (LPARAM) this;

	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = -1;		// May need modification
	m_resultDataItem.lParam = (LPARAM) this;

	pLocalSettings = new CLocalSettings(this);
	pServerList = new CServerList(this);

	this->root = root;
}

CSAFMQManagerRootNode::~CSAFMQManagerRootNode()
{
	delete pLocalSettings;
	delete pServerList;
}

HRESULT CSAFMQManagerRootNode::AddSAFMQServer(bool& handled, CSnapInObjectRootBase* pBase)
{
	HRESULT ret = ((CServerList*)pServerList)->AddSAFMQServer(handled, pBase);
	if (ret == S_OK)
		root->SetModified();
	return ret;
}


HRESULT CSAFMQManagerRootNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, long handle, IUnknown* pUnk, DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
		CSAFMQManagerRootPage* pPage = new CSAFMQManagerRootPage(handle, true, _T("SAFMQManagerRoot"));
		lpProvider->AddPage(pPage->Create());
		// The second parameter  to the property page class constructor
		// should be true for only one page.

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

HRESULT CSAFMQManagerRootNode::OnExpand(BOOL bExpand, IConsole *pConsole, HSCOPEITEM me) {
	CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(pConsole);

	if (me > 0)
		m_scopeDataItem.ID = me;
	
	SCOPEDATAITEM	*item;

	pLocalSettings->GetScopeData(&item);
	item->relativeID = m_scopeDataItem.ID;
	spConsoleNameSpace->InsertItem(item);

	pServerList->GetScopeData(&item);
	item->relativeID = m_scopeDataItem.ID;
	spConsoleNameSpace->InsertItem(item);

	return S_FALSE;
}

HRESULT CSAFMQManagerRootNode::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM me) {
	if (me > 0)
		m_scopeDataItem.ID = me;

	CComQIPtr<IResultData, &IID_IResultData> spResultData(pConsole);
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(pConsole);

	spResultData->DeleteAllRsltItems();

	if (bShow) {
		if (me != -1) {
			// Don't add columns if flagged as a refresh
			spHeaderCtrl->InsertColumn( 0, L"Name", 0,  MMCLV_AUTO);
		}
	}
	return S_OK;
}


HRESULT CSAFMQManagerRootNode::OnAddImages(IImageList* pImageList) {
	HRESULT hr = E_FAIL;
	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_SAFMQMANAGERROOT_16));
	if (hBitmap16 != NULL)
	{
		HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_SAFMQMANAGERROOT_32));
		if (hBitmap32 != NULL)
		{
			hr = pImageList->ImageListSetStrip((long*)hBitmap16, 
			(long*)hBitmap32, 0, RGB(0, 128, 128));
			if (FAILED(hr))
				ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		}
	}
	return S_OK;
}

LPOLESTR CSAFMQManagerRootNode::GetResultPaneColInfo(int nCol)
{
	if (nCol == 0)
		return m_bstrDisplayName;
	// TODO : Return the text for other columns
	return OLESTR("Override GetResultPaneColInfo");
}



HRESULT CSAFMQManagerRootNode::Load(IStream *pStm)
{
	return ((CServerList*)pServerList)->Load(pStm);
}

HRESULT CSAFMQManagerRootNode::Save(IStream *pStm)
{
	return ((CServerList*)pServerList)->Save(pStm);
}


// ////////////////////////////////////////////////////////////////////////////
// 
// Implementation of the CSAFMQManagerRoot, the MMC Snap-In Scope Item

HRESULT CSAFMQManagerRoot::Load(IStream *pStm)
{
	return ((CSAFMQManagerRootNode*)m_pNode)->Load(pStm);
}

HRESULT CSAFMQManagerRoot::Save(IStream *pStm, BOOL fClearDirty)
{
	if (fClearDirty)
		modified = false;
	return ((CSAFMQManagerRootNode*)m_pNode)->Save(pStm);
}

HRESULT CSAFMQManagerRoot::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CSAFMQManagerRoot, CSAFMQManagerRootComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;
	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK) {
		return E_UNEXPECTED;
	}

	return LoadImages(spImageList);
}

/**
A static method to be callable by other image requestors.  Loads the standard image
list and returns it in the pImageList parameter

@param pImageList receives th eimage list.
@return E_UNEXPECTED if the image list cannot be set, S_OK otherwise.
*/
HRESULT CSAFMQManagerRoot::LoadImages(IImageList* pImageList)
{
	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_STRIP_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_STRIP_32));
	if (hBitmap32 == NULL)
		return S_OK;

	if (pImageList->ImageListSetStrip((long*)hBitmap16, (long*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK) {
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	return S_OK;
}
